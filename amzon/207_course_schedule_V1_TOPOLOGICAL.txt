class Solution {
    class topolog
    {
        public Integer indegree = 0;
        public List<Integer> outnodes = new LinkedList<Integer>();
    }
    
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if(prerequisites.length == 0)
            return true;
        
        HashMap<Integer, topolog> graph = new HashMap<>();
        
        for(int[] prerequit:prerequisites)
        {
            topolog precourse = this.gettp(graph, prerequit[1]);
            topolog nextcourse = this.gettp(graph, prerequit[0]);
            
            precourse.outnodes.add(prerequit[0]);
            nextcourse.indegree += 1;
        }
        
        // start from course have no prerequisites
        int total = prerequisites.length;
        LinkedList<Integer> firstcourse = new LinkedList<Integer>();
        for(Map.Entry<Integer, topolog> entry : graph.entrySet())
        {
            topolog node = entry.getValue();
            if(node.indegree == 0)
                firstcourse.add(entry.getKey());
        }
        
        int removededges = 0;
        while(firstcourse.size() > 0)
        {
            Integer course = firstcourse.pop();
            
            for(Integer nextcourse : graph.get(course).outnodes)
            {
                topolog childnode = graph.get(nextcourse);
                childnode.indegree -= 1;
                removededges += 1;
                if(childnode.indegree == 0 )
                    firstcourse.add(nextcourse);
            }
        }
        if(removededges != total)
            return false;
        return true;
    }
    
    protected topolog gettp(HashMap<Integer, topolog> graph, Integer course)
        {
            topolog node = null;
            if(graph.containsKey(course))
            {
                node = graph.get(course);
            }
            else
            {
                node = new topolog();
                graph.put(course, node);
            }
            return node;
        }
}