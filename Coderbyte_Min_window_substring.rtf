{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue255;\red255\green255\blue254;\red34\green34\blue34;
\red245\green245\blue245;\red0\green0\blue0;\red144\green1\blue18;\red19\green118\blue70;\red15\green112\blue1;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c100000;\cssrgb\c100000\c100000\c99608;\cssrgb\c17647\c17647\c17647;
\cssrgb\c96863\c96863\c96863;\cssrgb\c0\c0\c0;\cssrgb\c63922\c8235\c8235;\cssrgb\c3529\c52549\c34510;\cssrgb\c0\c50196\c0;
}
\margl1440\margr1440\vieww17100\viewh13200\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 /*\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5 \strokec4 Input:\'a0\cb1 \{"ahffaksfajeeubsne", "jefaa"\}\
\cb5 Output:\'a0\cb1 aksfaje\cb5 Input:\'a0\cb1 \{"ahffaksfajeeubsne", "jefaa"\}\
\cb5 Output:\'a0\cb1 aksfaje
\f0 \cf2 \cb3 \strokec2 \
\pard\pardeftab720\partightenfactor0
\cf2 */\
#include\cf0 \strokec6  \cf2 \strokec2 <\cf7 \strokec7 iostream\cf2 \strokec2 >\cf0 \cb1 \strokec6 \
\cf2 \cb3 \strokec2 #include\cf0 \strokec6  \cf2 \strokec2 <\cf7 \strokec7 string\cf2 \strokec2 >\cf0 \cb1 \strokec6 \
\cf2 \cb3 \strokec2 #include\cf0 \strokec6  \cf2 \strokec2 <\cf7 \strokec7 limits.h\cf2 \strokec2 >\cf0 \cb1 \strokec6 \
\cf2 \cb3 \strokec2 #include\cf0 \strokec6  \cf2 \strokec2 <\cf7 \strokec7 unordered_map\cf2 \strokec2 >\cf0 \cb1 \strokec6 \
\cf2 \cb3 \strokec2 using\cf0 \strokec6  \cf2 \strokec2 namespace\cf0 \strokec6  std;\cb1 \
\
\cf2 \cb3 \strokec2 bool\cf0 \strokec6  checking(unordered_map<\cf2 \strokec2 char\cf0 \strokec6 , \cf2 \strokec2 int\cf0 \strokec6 > &mp)\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 \{\cb1 \
\cb3   \cf2 \strokec2 for\cf0 \strokec6 (\cf2 \strokec2 auto\cf0 \strokec6  it:mp)\cb1 \
\cb3     \cf2 \strokec2 if\cf0 \strokec6 (it.second > \cf8 \strokec8 0\cf0 \strokec6 )\cb1 \
\cb3       \cf2 \strokec2 return\cf0 \strokec6  \cf2 \strokec2 false\cf0 \strokec6 ;\cb1 \
\cb3     \cf2 \strokec2 return\cf0 \strokec6  \cf2 \strokec2 true\cf0 \strokec6 ;\cb1 \
\cb3 \}\cb1 \
\
\cb3 string MinWindowSubstring(string strArr[], \cf2 \strokec2 int\cf0 \strokec6  arrLength) \{\cb1 \
\cb3   string s = strArr[\cf8 \strokec8 0\cf0 \strokec6 ];\cb1 \
\cb3   string target = strArr[\cf8 \strokec8 1\cf0 \strokec6 ];\cb1 \
\cb3   unordered_map<\cf2 \strokec2 char\cf0 \strokec6 , \cf2 \strokec2 int\cf0 \strokec6 > mp;\cb1 \
\cb3   \cf2 \strokec2 for\cf0 \strokec6 (\cf2 \strokec2 auto\cf0 \strokec6  c:target) mp[c]++;\cb1 \
\
\cb3   \cf2 \strokec2 int\cf0 \strokec6  left = \cf8 \strokec8 0\cf0 \strokec6 ;\cb1 \
\cb3   \cf2 \strokec2 int\cf0 \strokec6  start_index = -\cf8 \strokec8 1\cf0 \strokec6 ;\cb1 \
\cb3   \cf2 \strokec2 int\cf0 \strokec6  result = INT_MAX;\cb1 \
\cb3   \cf2 \strokec2 bool\cf0 \strokec6  findall = \cf2 \strokec2 false\cf0 \strokec6 ;\cb1 \
\cb3   \cf2 \strokec2 for\cf0 \strokec6 (\cf2 \strokec2 int\cf0 \strokec6  end=\cf8 \strokec8 0\cf0 \strokec6 ; end<s.size(); end++)\cb1 \
\cb3   \{\cb1 \
\cb3     \cf2 \strokec2 if\cf0 \strokec6 (mp.count(s[end]))\cb1 \
\cb3     \{ \cb1 \
\cb3       \cf2 \strokec2 if\cf0 \strokec6 (left==-\cf8 \strokec8 1\cf0 \strokec6 ) \cb1 \
\cb3         left = end;\cb1 \
\cb3       mp[s[end]]--;\cb1 \
\cb3       findall = checking(mp);\cb1 \
\cb3     \}\cb1 \
\
\cb3   \cb1 \
\cb3     \cf2 \strokec2 while\cf0 \strokec6 (findall)\cb1 \
\cb3     \{\cb1 \
\cb3       \cf2 \strokec2 if\cf0 \strokec6 (result > end-left+\cf8 \strokec8 1\cf0 \strokec6 )\cb1 \
\cb3       \{\cb1 \
\cb3         start_index = left;\cb1 \
\cb3         result = end-left+\cf8 \strokec8 1\cf0 \strokec6 ;\cb1 \
\cb3       \}\cb1 \
\cb3  \cf9 \strokec9 //cout << left << ":"<<s[left] << " and " << end << ":" << s[end]<<endl;\cf0 \cb1 \strokec6 \
\cb3       \cf9 \strokec9 // remove the first match \cf0 \cb1 \strokec6 \
\cb3       mp[s[left]]++;\cb1 \
\cb3       left++;\cb1 \
\cb3       findall = checking(mp);\cb1 \
\cb3       \cb1 \
\cb3       \cf9 \strokec9 // move left to new match location\cf0 \cb1 \strokec6 \
\cb3       \cf2 \strokec2 while\cf0 \strokec6 (!mp.count(s[left]))\cb1 \
\cb3       \{\cb1 \
\cb3         left++;\cb1 \
\cb3       \}\cb1 \
\cb3     \}\cb1 \
\cb3   \}\cb1 \
\
\cb3   \cf2 \strokec2 if\cf0 \strokec6 (result!=-\cf8 \strokec8 1\cf0 \strokec6 )\cb1 \
\cb3     \cf2 \strokec2 return\cf0 \strokec6  s.substr(start_index, result);\cb1 \
\cb3   \cb1 \
\cb3   \cf2 \strokec2 return\cf0 \strokec6  \cf7 \strokec7 ""\cf0 \strokec6 ;\cb1 \
\cb3 \}\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 int\cf0 \strokec6  main(\cf2 \strokec2 void\cf0 \strokec6 ) \{ \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3    \cb1 \
\cb3   \cf9 \strokec9 // keep this function call here\cf0 \cb1 \strokec6 \
\cb3   string A[] = coderbyteInternalStdinFunction(stdin);\cb1 \
\cb3   \cf2 \strokec2 int\cf0 \strokec6  arrLength = \cf2 \strokec2 sizeof\cf0 \strokec6 (A) / \cf2 \strokec2 sizeof\cf0 \strokec6 (*A);\cb1 \
\cb3   cout << MinWindowSubstring(A, arrLength);\cb1 \
\cb3   \cf2 \strokec2 return\cf0 \strokec6  \cf8 \strokec8 0\cf0 \strokec6 ;\cb1 \
\cb3     \cb1 \
\cb3 \}\cb1 \
v}